/*                                                         
 *   Implement the filter and projection functions for 
 *   each of the registered virtual tables.
 *                                                         
 *   Copyright 2012 Marios Fragkoulis
 *                                                         
 *   Licensed under the Apache License, Version 2.0        
 *   (the "License");you may not use this file except in   
 *   compliance with the License.                          
 *   You may obtain a copy of the License at               
 *                                                         
 *       http://www.apache.org/licenses/LICENSE-2.0        
 *                                                         
 *   Unless required by applicable law or agreed to in     
 *   writing, software distributed under the License is    
 *   distributed on an "AS IS" BASIS.                      
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  
 *   express or implied.                                   
 *   See the License for the specific language governing   
 *   permissions and limitations under the License.
 */

#include <cassert>
#include <cstdio>
#include <cstring>
#include <string>
#include <map>
#include <boost/concept_check.hpp>
<%= directives %>
#include "stl_search.h"
#include "user_functions.h"
#include "workers.h"


using namespace std;
using namespace boost;

template <class T>
void forward_container_concept_check(T x) {
    BOOST_CONCEPT_ASSERT((ForwardContainer<T>));
};

template <class It>
class forward_iterator_concept_class {
    BOOST_CONCEPT_ASSERT((ForwardIterator<It>));
};

struct name_cmp {
    bool operator()(const char *a, const char *b) {
        return strcmp(a, b) < 0;
    }
};

static map<const char *, int, name_cmp> vt_directory;
static map<const char *, int, name_cmp>::iterator vtd_iter;


<%     @tables.each { |vt| %>
<%      if vt.base_var.length > 0 %>
<%= vt.signature %> <%= vt.base_var %>;
<%      end %>
<%     } %>


// Thread. Creates the queries and passes them on to PiCO_QL.
void * thread_sqlite(void *data) {
    const char **queries, **table_names;
    queries = (const char **)sqlite3_malloc(sizeof(char *) *
                   <%= @tables.length.to_s %>);
    table_names = (const char **)sqlite3_malloc(sizeof(char *) *
                   <%= @tables.length.to_s %>);
    int failure = 0;
<%# <db>.<table> does not work for some reason. test. %>
<%    @tables.each_index { |vt| %>
<%#      query =  "CREATE VIRTUAL TABLE #{@tables[vt].db}.#{@tables[vt].name} USING stl(" %>
<%      query =  "CREATE VIRTUAL TABLE #{@tables[vt].name} USING stl(" %>
<%      @tables[vt].columns.each { |c| %>
<%        query += "#{c.name} #{c.data_type}, " %>
<%      } %>
<%      query = query.chomp(", ") + ")" %>
    queries[<%= vt %>] = "<%= query %>";
    table_names[<%= vt %>] = "<%= @tables[vt].name %>";
<%    } %>
    failure = register_table( "<%= @tables[0].db %>" , <%= @tables.length.to_s %>, queries, table_names, data);
    printf("Thread sqlite returning..\n");
    sqlite3_free(queries);
    sqlite3_free(table_names);
    return (void *)failure;
}


// The API with user application code. Creates the PiCO_QL thread.
int call_pico_ql() {
    pthread_t sqlite_thread;
    int re_sqlite = pthread_create(&sqlite_thread, NULL, thread_sqlite, NULL);
    pthread_join(sqlite_thread, NULL);
    return re_sqlite;
}


/* Registers the base variables of user application code
 * with their virtual table representation.
 */
void register_vt(stlTable *stl) {
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].base_var.length > 0 %>
<%        if count == 0 %>
    if (!strcmp(stl->zName, "<%= @tables[vt].name %>")) {
<%	  count += 1 %>
<%        else %>
    } else if (!strcmp(stl->zName, "<%= @tables[vt].name %>")) {
<%        end %>
<%        /\*/.match(@tables[vt].pointer) == nil ? retype = "&" : retype = "" %>
        stl->data = (void *)<%= retype %><%= @tables[vt].base_var %>;
        stl->embedded = 0;
<%      end %>
<%    } %>
    } else {
        stl->data = NULL;
        stl->embedded = 1;
    }
    vt_directory[stl->zName] = 0;
}


// Returns the size (records) for each virtual table.
int get_datastructure_size(sqlite3_vtab_cursor *cur) {
    stlTableCursor *stc = (stlTableCursor *)cur;
    stlTable *stl = (stlTable *)cur->pVtab;
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].container_class.length > 0 %>
<%        if count == 0 %>
    if (!strcmp(stl->zName, "<%= @tables[vt].name %>")) {
<%	  count += 1 %>
<%        else %>
    } else if (!strcmp(stl->zName, "<%= @tables[vt].name %>")) {
<%        end %>
<%        /\*/.match(@tables[vt].pointer) == nil ? retype = "*" : retype = "" %>
<%# Chomp the pointer from signature. %>
<%# For non-pointers it will have zero effect. %>
        <%= @tables[vt].signature.chomp('*') %> container_instance;
        forward_container_concept_check(container_instance);
        forward_iterator_concept_class<<%= @tables[vt].signature.chomp('*') %>::iterator> it;
        <%= @tables[vt].signature %><%= retype %> any_dstr = (<%= @tables[vt].signature %><%= retype %>)stc->source;
        return (int)any_dstr->size();
<%      end %>
<%    } %>
    }
    return 1;
}


// Each embedded virtual table has a column named 'base'.
// This function checks if a provided column name is indeed 'base'.
int equals_base(const char *zCol) {
    int length = (int)strlen(zCol) + 1;
    char copy[length], *token;
    memcpy(copy, zCol, length);
    token = strtok(copy, " ");
    if (token != NULL) {
        if (!strcmp(token, "base"))
            return true;
        else
            return false;
    } else
        return SQLITE_NOMEM;
}


