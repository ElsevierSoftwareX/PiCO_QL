/*
 *
 *   Automatically-generated file.  Do not modify.
 *   Modify pico_ql_directives_utils_cpp.erb and pico_ql_generator.rb
 *   instead.
 *
 *   Implement the filter and projection functions for
 *   each of the registered virtual tables.
 *
 *   Copyright 2012 Marios Fragkoulis
 *
 *   Licensed under the Apache License, Version 2.0
 *   (the "License");you may not use this file except in
 *   compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in
 *   writing, software distributed under the License is
 *   distributed on an "AS IS" BASIS.
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *   express or implied.
 *   See the License for the specific language governing
 *   permissions and limitations under the License.
 */

#include <cassert>
#include <cstdio>
#include <cstring>
#include <string>
#include <map>
#include <set>
#ifdef PICO_QL_HANDLE_TEXT_ARRAY
#include <vector>
#endif
#include <list>
<%# list include..not always. At least on fk_col_type.length > 0 %>
#include <boost/concept_check.hpp>
#include <boost/dynamic_bitset.hpp>
#ifndef PICO_QL_SINGLE_THREADED
#include <pthread.h>
#endif
<%= directives %>
#include "pico_ql_internal.h"
#include "pico_ql_search_helper.h"
#include "pico_ql_interface.h"


using namespace std;
using namespace boost;

namespace picoQL {

template <class T>
void forward_container_concept_check(T x) {
  BOOST_CONCEPT_ASSERT((ForwardContainer<T>));
  (void)x;
};

template <class It>
class forward_iterator_concept_class {
  BOOST_CONCEPT_ASSERT((ForwardIterator<It>));
};

// For the compiler to verify.
void check_concepts() {
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].container_class.length > 0 && !VirtualTable.C_container_types.include?(@tables[vt].container_class) %>
<%# Chomp the pointer from signature. %>
<%# For non-pointers it will have zero effect. %>
  <%= @tables[vt].signature.chomp('*') %> container_instance<%= vt %>;
  forward_container_concept_check(container_instance<%= vt %>);
  forward_iterator_concept_class<<%= @tables[vt].signature.chomp('*') %>::iterator> it<%= vt %>;
  (void)it<%= vt %>;	// Silence compiler unused variable warning
 
<%      end %>
<%    } %>
}


struct name_cmp {
  bool operator()(const char *a, const char *b) {
    return strcmp(a, b) < 0;
  }
};

static map<string, VtblImpl*> selector_vt;

<%     @tables.each { |vt| %>
<%      if vt.base_var.length > 0 %>
<%        /\*/.match(vt.pointer) == nil ? retype = "*" : retype = "" %>
<%        if $argD == "DEBUG" %>
// C NAME (pico_ql_table_)<%= vt.base_var %> in line <%= vt.base_var_line + 1 %> <%= $argF %> 
<%        end %>
extern <%= vt.signature %> <%= retype %>pico_ql_table_<%= vt.base_var %>;
<%        if $argD == "DEBUG" %>
#line <%= vt.signature_line + 1 %> "<%= $argF %>" 
<%        end %>
<%      end %>
<%     } %>


// Thread. Creates the queries and passes them on to PiCO_QL.
void * thread_sqlite(void *data) {
  const char **queries, **sqlite_names;
<% view_length = 0 %>
<% @views == nil ? views_length = 0 : views_length = @views.length %>
  queries = (const char **)sqlite3_malloc(sizeof(char *) * <%= (@tables.length + views_length).to_s %>);
  sqlite_names = (const char **)sqlite3_malloc(sizeof(char *) * <%= (@tables.length + views_length).to_s %>);
  int failure = 0;
<%# <db>.<table> does not work for some reason. test. %>
<%# counter %>
<%    @tables.each_index { |vt| %>
<%#     query =  "CREATE VIRTUAL TABLE #{@tables[vt].db}.#{@tables[vt].name} USING PicoQL(" %>
<%      query =  "CREATE VIRTUAL TABLE #{@tables[vt].name} USING PicoQL(" %>
<%      @tables[vt].columns.each { |c| %>
<%        query += "#{c.name} #{c.data_type}, " %>
<%      } %>
<%      query = query.chomp(", ") + ")" %>
  queries[<%= vt %>] = "<%= query %>";
  sqlite_names[<%= vt %>] = "<%= @tables[vt].name %>";
<%    } %>
<%    if views_length > 0 %>
<%      @views.each_index { |vs| %>
  queries[<%= vs + @tables.length %>] = "<%= @views[vs].stmt %>";
  sqlite_names[<%= vs + @tables.length %>] = "<%= @views[vs].name %>";
<%      } %>
<%    end %>
  set_selectors();
  int port_number = *(int *)data;
  delete (int *)data;
  failure = register_table( "<%= @tables[0].db %>" , <%= (@tables.length + views_length).to_s %>, <%= @tables.length.to_s %>, queries, sqlite_names, port_number);
  printf("Thread sqlite returns %i\n", failure);
  sqlite3_free(queries);
  sqlite3_free(sqlite_names);
  return NULL;
}


/* Registers the base variables of user application code
 * with their virtual table representation.
 */
int register_vt(picoQLTable *picoQL) {
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].base_var.length > 0 %>
<%        if count == 0 %>
  if (!strcmp(picoQL->zName, "<%= @tables[vt].name %>")) {
<%	  count += 1 %>
<%        else %>
  } else if (!strcmp(picoQL->zName, "<%= @tables[vt].name %>")) {
<%        end %>
<%# Retyping has been taken care of in register_pico_ql %>
<%#        /\*/.match(@tables[vt].pointer) == nil ? retype = "&" : retype = "" %>
<%        if $argD == "DEBUG" %>
#line <%= @tables[vt].base_var_line + 1 %> "<%= $argF %>" 
<%        end %>
    if (pico_ql_table_<%= @tables[vt].base_var %> == NULL)
      return SQLITE_ERROR;
    picoQL->data = (void *)pico_ql_table_<%= @tables[vt].base_var %>;
    picoQL->embedded = 0;
<%      end %>
<%    } %>
  } else {
    picoQL->data = NULL;
    picoQL->embedded = 1;
  }
  return SQLITE_INTERNAL;
}


// Each embedded virtual table has a column named 'base'.
// This function checks if a provided column name is indeed 'base'.
int equals(const char *zCol, const char *key) {
  int length = (int)strlen(zCol) + 1;
  char copy[length], *token;
  memcpy(copy, zCol, length);
  token = strtok(copy, " ");
  if (token != NULL) {
    if (!strcmp(token, key))
      return true;
    else
      return false;
  } else
    return SQLITE_NOMEM;
}

/* Deinitiates vectors which store temporary FK
 * column values so that they are
 * manageable by SQLite safely.
 */
void deinit_temp_structs(void) {
<%     @tables.each { |vt| %>
  VtblImpl *discharge<%= vt.name %>VT = selector_vt["<%= vt.name %>"];
  (*discharge<%= vt.name %>VT)("clear_saved_results");
<%      if vt.base_var.length == 0 %>
  map<sqlite3_vtab_cursor *, bool> *map<%= vt.name %>;
  map<%= vt.name %> = NULL;
  (*discharge<%= vt.name %>VT)(NULL, 0, map<%= vt.name %>);
<%      end %>
<%     } %>
}

/* Deinitiates map which stores pairs of
 * virtual table names to functors virtualizing
 * individual VT search/retrieve implementations.
 */
void deinit_vt_selectors(void) {
  map<string, VtblImpl *>::iterator it;
  for (it = selector_vt.begin(); it != selector_vt.end(); it++)
    delete it->second;
}

<%     @tables.each { |vt| %>
class <%= vt.name %>_vt : public VtblImpl {
private:
<%      i = 0 %>
<%      vt.columns.each { |col| %>
<%       if col.related_to.length > 0 %>
<%        col.fk_col_type = $table_index[col.related_to] %>
<%        if $argM == "MEM_MGT" && col.fk_method_ret == 1 %>
list <<%= col.fk_col_type.chomp('*') %> > saved_results_<%= i %>;
<%        end %>
<%        col.saved_results_index = i %>
<%        i += 1 %>
<%       end %>
<%      } %>
#ifdef PICO_QL_HANDLE_TEXT_ARRAY
/* Dynamic vector which stores resultset column
 * values of type char array so that they are retrievable
 * by SQLite without conflict.
 */
  vector<string> textVector;
#endif
<%      if vt.container_class.length > 0 %>
  class ResultSet {
  public:
<%        if VirtualTable.C_container_types.include?(vt.container_class) %>
<%          vt.pointer.match(/\*/) ? retype = "" : retype = "*" %>
    vector<<%= vt.signature %><%= retype %>> res;
    vector<<%= vt.signature %><%= retype %>>::iterator resIter;
<%        else %>
    vector<<%= vt.signature.chomp('*') %>::iterator> res;
    vector<<%= vt.signature.chomp('*') %>::iterator>::iterator resIter;
<%        end %>
    dynamic_bitset<unsigned long> resBts;
    int resultSetIterState;
    int offset;
<%        if VirtualTable.C_container_types.include?(vt.container_class) %>
<%          vt.pointer.match(/\*/) ? retype = "" : retype = "*" %>
    ResultSet(int res_max_size, int resIterState, int off, vector<<%= vt.signature %><%= retype %>>::iterator it) {
<%        else %>
    ResultSet(int res_max_size, int resIterState, int off, vector<<%= vt.signature.chomp('*') %>::iterator>::iterator it) {
<%        end %>
      resBts.resize(res_max_size);
      resultSetIterState = resIterState;
      offset = off;
      resIter = it;
    };
    ResultSet() {};
    ~ResultSet() {resBts.clear();};
  };
  map<sqlite3_vtab_cursor *, ResultSet> cursors;
<%        if VirtualTable.C_container_types.include?(vt.container_class) %>
<%          vt.pointer.match(/\*/) ? retype = "" : retype = "*" %> 
  vector<<%= vt.signature %><%= retype %>>::iterator resIterC;
  <%= vt.signature %><%= retype %> iter;
<%        else %>
  vector<<%= vt.signature.chomp('*') %>::iterator>::iterator resIterC;
  <%= vt.signature.chomp('*') %>::iterator iter;
<%        end %>
<%      else %>
  set<sqlite3_vtab_cursor *> cursors;
<%      end %>
<%      if vt.base_var.length == 0 %>
  map<sqlite3_vtab_cursor *, bool> charged;
  int recursive;
<%      end %>
public:
  <%= vt.name %>_vt() : VtblImpl() {
<% if vt.base_var.length == 0 %>    recursive = 0;<% end %>};
  virtual int operator() (sqlite3_vtab_cursor *, int,
                    int, sqlite3_value *);
  virtual int operator() (sqlite3_vtab_cursor *,
                    int, sqlite3_context *);
  virtual size_t operator() (sqlite3_vtab_cursor *, sqlite3_vtab *);
  virtual int operator() (sqlite3_vtab_cursor *);
  virtual void operator() (sqlite3_vtab_cursor *, void *);
  virtual void operator() (sqlite3_vtab *, sqlite3_vtab_cursor *);
<%      if vt.base_var.length == 0 %>
  virtual void operator() (sqlite3_vtab_cursor *cur, int current, map<sqlite3_vtab_cursor *, bool> *oCharged) {
    pair<map<sqlite3_vtab_cursor *, bool>::iterator, bool> operation;
    if (current) {
      operation = charged.insert(pair<sqlite3_vtab_cursor *, bool>(cur, false));
      if ((operation.second) && (oCharged != NULL)) {
        map<sqlite3_vtab_cursor *, bool>::iterator iter;
        for (iter = oCharged->begin(); iter != oCharged->end(); iter++) {
          if (cursors.find(iter->first) != cursors.end()) {
            if (!iter->second) {
              recursive += 1;
              iter->second = true;
            }
          }
        }
      }
    } else {
      charged.clear();
      recursive = 0;
    }
  };
<%      else %>
  virtual void operator() (sqlite3_vtab_cursor *, int, map<sqlite3_vtab_cursor *, bool> *) {};
<%      end %>

  virtual void operator() (const char *dummy) {
    (void)dummy;
<%      vt.columns.each { |col| %>
<%       if $argM == "MEM_MGT" && col.related_to.length > 0 && col.fk_method_ret == 1 %>
    saved_results_<%= col.saved_results_index %>.clear();    
<%       end %>
<%      } %>
  };
};
 
<%     } %>
 
 
