/*
 *
 *   Automatically-generated file.  Do not modify.
 *   Modify pico_ql_directives_utils_c.erb and pico_ql_generator.rb
 *   instead.
 *
 *   Implement the filter and projection functions for
 *   each of the registered virtual tables.
 *
 *   Copyright 2012 Marios Fragkoulis
 *
 *   Licensed under the Apache License, Version 2.0
 *   (the "License");you may not use this file except in
 *   compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in
 *   writing, software distributed under the License is
 *   distributed on an "AS IS" BASIS.
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *   express or implied.
 *   See the License for the specific language governing
 *   permissions and limitations under the License.
 */

#include <assert.h>
#include <stdio.h>
#include <string.h>

<%#include <list> %>
<%# list include..not always. At least on fk_col_type.length > 0 %>

#ifndef PICO_QL_SINGLE_THREADED
#include <pthread.h>
#endif
<%= directives %>
#include "pico_ql_internal.h"
#include "pico_ql_search_helper.h"
#include "pico_ql_interface.h"


<%     @tables.each { |vt| %>
<%      if vt.base_var.length > 0 %>
<%        /\*/.match(vt.pointer) == nil ? retype = "*" : retype = "" %>
<%        if $argD == "DEBUG" %>
// C NAME (pico_ql_table_)<%= vt.base_var %> in line <%= vt.base_var_line + 1 %> <%= $argF %> 
<%        end %>
extern <%= vt.signature %> <%= retype %>pico_ql_table_<%= vt.base_var %>;
<%        if $argD == "DEBUG" %>
#line <%= vt.signature_line + 1 %> "<%= $argF %>" 
<%        end %>
<%      end %>
<%     } %>

/* Registers the base variables of user application code
 * with their virtual table representation.
 */
int register_vt(picoQLTable *picoQL) {
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].base_var.length > 0 %>
<%        if count == 0 %>
  if (!strcmp(picoQL->zName, "<%= @tables[vt].name %>")) {
<%	  count += 1 %>
<%        else %>
  } else if (!strcmp(picoQL->zName, "<%= @tables[vt].name %>")) {
<%        end %>
<%# Retyping has been taken care of in register_pico_ql %>
<%#        /\*/.match(@tables[vt].pointer) == nil ? retype = "&" : retype = "" %>
<%        if $argD == "DEBUG" %>
#line <%= @tables[vt].base_var_line + 1 %> "<%= $argF %>" 
<%        end %>
    if (pico_ql_table_<%= @tables[vt].base_var %> == NULL)
      return SQLITE_ERROR;
    picoQL->data = (void *)pico_ql_table_<%= @tables[vt].base_var %>;
    picoQL->embedded = 0;
<%      end %>
<%    } %>
  } else {
    picoQL->data = NULL;
    picoQL->embedded = 1;
  }
  return SQLITE_INTERNAL;
}


// Each embedded virtual table has a column named 'base'.
// This function checks if a provided column name is indeed 'base'.
int equals(const char *zCol, const char *key) {
  int length = (int)strlen(zCol) + 1;
  char copy[length], *token;
  memcpy(copy, zCol, length);
  token = strtok(copy, " ");
  if (token != NULL) {
    if (!strcmp(token, key))
      return true;
    else
      return false;
  } else
    return SQLITE_NOMEM;
}

<%# TODO %>
/* Deinitiates vectors which store temporary FK
 * column values so that they are
 * manageable by SQLite safely.
 */
void deinit_temp_structs() {
<%     @tables.each { |vt| %>
  VtblImpl *discharge<%= vt.name %>VT = selector_vt["<%= vt.name %>"];
  (*discharge<%= vt.name %>VT)("clear_saved_results");
<%      if vt.base_var.length == 0 %>
  map<sqlite3_vtab_cursor *, bool> *map<%= vt.name %>;
  map<%= vt.name %> = NULL;
  (*discharge<%= vt.name %>VT)(NULL, 0, map<%= vt.name %>);
<%      end %>
<%     } %>
}

<%# TODO %>
/* Deinitiates map which stores pairs of
 * virtual table names to functors virtualizing
 * individual VT search/retrieve implementations.
 */
void deinit_vt_selectors() {
  map<string, VtblImpl *>::iterator it;
  for (it = selector_vt.begin(); it != selector_vt.end(); it++)
    delete it->second;
}

struct Vtbl {

  int (*search)(sqlite3_vtab_cursor *, int,
                    int, sqlite3_value *);
  int (*retrieve)(sqlite3_vtab_cursor *,
                    int, sqlite3_context *);
  size_t (*get_datastructure_size)(sqlite3_vtab_cursor *, 
                                         sqlite3_vtab *);
  void (*init_resultSet)(sqlite3_vtab *, sqlite3_vtab_cursor *);
  int (*next_resultSet)(sqlite3_vtab_cursor *);
  void (*deinit_resultSet)(sqlite3_vtab_cursor *cur, void *shadowRes);
  void (*report_charge)(sqlite3_vtab_cursor *cur, int current, 
       			     struct *oCharged);
  void (*discharge_saved_results)(const char *dummy);

};

struct ResultSet {
  
  void **res;
  int current;
  int size;
  int resultSetIterState;

};

struct Cursor {

  sqlite3_vtab_cursor *cur;
  struct ResultSet res;

};

struct Charged {

  sqlite3_vtab_cursor *cur;
  int charged;

};

<%     @tables.each { |vt| %>
struct VtblImpl {

  const char *name;
  struct Vtbl *impl;
  struct Cursor **cursors;
  struct Charged **chrg;
<%      i = 0 %>
<%      vt.columns.each { |col| %>
<%       if col.related_to.length > 0 %>
<%        col.fk_col_type = $table_index[col.related_to] %>
<%        if $argM == "MEM_MGT" && col.fk_method_ret == 1 %>
  struct saved_results_<%= i %> {
    struct <<%= col.fk_col_type.chomp('*') %> **captcha;
    int size;
  };
 
<%        end %>
<%        col.saved_results_index = i %>
<%        i += 1 %>
<%       end %>
<%      } %>

} <%= vt.name %>_vt;

<%     } %>
