// Filters column values of virtual table <%= @name %>.
int <%= @name %>_vt::operator() (sqlite3_vtab_cursor *cur, int op, int nCol, sqlite3_value *val) {
  picoQLTable *picoQL = (picoQLTable *)cur->pVtab;
  (void)picoQL;	// Silence compiler unused variable warning
  picoQLTableCursor *stcsr = (picoQLTableCursor *)cur;
<%      if @container_class.length > 0 %>
  int index = 0;
  ResultSet rs = cursors[cur];
  int rowNum = -1;
<%      end %>
  if (struct_empty_null(cur, val, picoQL->embedded, nCol)) {
<%      if @container_class.length == 0 %>
    stcsr->size = 1;
<%	else %>
    for (resIterC = rs.res.begin(); resIterC != rs.res.end(); resIterC++)
      delete *resIterC;
    rs.res.clear();
    rs.resBts.clear();
    rs.res.push_back(new <%= @signature.chomp('*') %>::iterator());
    *(rs.resIter) = rs.res.begin();
<%      end %>
    return SQLITE_OK;
  }
<%      if /\*/.match(@pointer) == nil %>
<%        sign_retype = "#{@signature}*" %>
<%        sign_untype = @signature %>
<%      else %>
<%        sign_retype = @signature %>
<%        sign_untype = @signature.chomp("*") %>
<%      end %>
  <%= sign_retype %> any_dstr = (<%= sign_retype %>)stcsr->source;
<%        if $argD == "DEBUG" %>
#line <%= @signature_line + 1 %> "<%= $argF %>" 
<%        end %>
  int first_constr = stcsr->first_constr;
  if (first_constr)
    stcsr->first_constr = 0;
  if (val == NULL) {
<%      if @base_var.length > 0 %>
<%        if @container_class.length > 0 %>
    for (iter = any_dstr->begin(); iter != any_dstr->end(); iter++) {
      rs.res.push_back(new <%= @signature.chomp('*') %>::iterator(iter));
      rs.resBts.set();
    }
<%        else %>
    stcsr->size = 1;
<%        end %>
<%      else %>
    printf("Searching embedded VT <%= @name %> with no BASE constraint makes no sense.\n");
    return SQLITE_MISUSE;
<%      end %>
  } else {
<%      if @base_var.length == 0 %>
    if (first_constr) {
      if (equals(picoQL->azColumn[nCol], "base")) {
        int chSize = charged.size();
        int cuSize = cursors.size();
        if ((cuSize == chSize) || (cuSize == chSize - recursive)) {
#ifdef ENVIRONMENT64
          stcsr->source = (void *)sqlite3_value_int64(val);
#else
          stcsr->source = (void *)sqlite3_value_int(val);
#endif
          if (stcsr->source == NULL) {
            stcsr->isInstanceNULL = 1;
<%        if @container_class.length == 0 %>
            stcsr->size = 1;
<%	  else %>
// BASE is first constraint by default, so no need to delete resultset here.
            rs.res.push_back(new <%= @signature.chomp('*') %>::iterator());
<%        end %>
            return SQLITE_OK;
          }
          stcsr->isInstanceNULL = 0;
          any_dstr = (<%= sign_retype %>)stcsr->source;
<%        if @container_class.length > 0 %>
          if ((stcsr->max_size = (int)(*this)(cur, cur->pVtab)) == 0) {
            stcsr->isInstanceEmpty = 1;
            rs.res.push_back(new <%= @signature.chomp('*') %>::iterator());
            return SQLITE_OK;
          } else {
            rs.resBts.resize(stcsr->max_size, 0);
          }
<%        end %>
          stcsr->isInstanceEmpty = 0;
        } else {
          printf("Searching embedded VT <%= @name %> with invalid BASE constraint.\n");
          return SQLITE_MISUSE;
        }
      } else { 
        printf("Searching embedded VT <%= @name %> with first constraint other than BASE constraint.\n");
        return SQLITE_MISUSE;
      }
    }
<%      end %>
