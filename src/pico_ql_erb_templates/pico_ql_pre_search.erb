// Filters column values of virtual table <%= @name %>.
int <%= @name %>_search(sqlite3_vtab_cursor *cur, char *constr, sqlite3_value *val) {
    picoQLTable *picoQL = (picoQLTable *)cur->pVtab;
    (void)picoQL;	// Silence compiler unused variable warning
    picoQLTableCursor *stcsr = (picoQLTableCursor *)cur;
    if (struct_empty_null(cur, val, picoQL->embedded, constr)) return SQLITE_OK;
<%      if /\*/.match(@pointer) == nil %>
<%        sign_retype = "#{@signature}*" %>
<%        sign_untype = @signature %>
<%      else %>
<%        sign_retype = @signature %>
<%        sign_untype = @signature.chomp("*") %>
<%      end %>
<%      if $argD == "DEBUG" %>
// C TYPE <%= @signature %> in line <%= @signature_line + 1 %> <%= $argF %> 
<%      end %>
    <%= sign_retype %> any_dstr = (<%= sign_retype %>)stcsr->source;
<%      if @container_class.length > 0 %>
    <%= sign_untype %>:: iterator iter;
<%      else %>
    int i = 0;
<%      end %>
    int op, iCol, count = 0, re = 0;
<%      if @base_var.length > 0 %>
    int size = stcsr->max_size;
<%      else %>
    int size;
    if (picoQL->zErr) {
        sqlite3_free(picoQL->zErr);
        return SQLITE_MISUSE;
    }
<%      end %>
    if (val == NULL) {
<%      if @base_var.length > 0 %>
<%        if @container_class.length > 0 %>
        for (int j = 0; j < size; j++) {
            stcsr->resultSet[j] = j;
            stcsr->size++;
	}
        assert(stcsr->size <= stcsr->max_size);
        assert(&stcsr->resultSet[stcsr->size] <= &stcsr->resultSet[size]);
<%        else %>
        stcsr->size++;
<%        end %>
<%      else %>
        printf("Searching VT <%= @name %> with no BASE constraint...makes no sense.\n");
        return SQLITE_MISUSE;
<%      end %>
    } else {
        check_alloc((const char *)constr, op, iCol);
<%      if @base_var.length == 0 %>
        if (equals(picoQL->azColumn[iCol], "base")) {
<%        if $argT == "TYPESAFE" %>
            vtd_iter = vt_directory.find(picoQL->zName);
            if ((vtd_iter == vt_directory.end()) || (vtd_iter->second == 0)) {
                printf("Invalid cast to %s\n", picoQL->zName);
                return SQLITE_MISUSE;
            }
            vt_directory[picoQL->zName] = 0;
<%        end %>
            stcsr->source = (void *)sqlite3_value_int64(val);
	    if (stcsr->source == NULL) {
	        stcsr->isInstanceNULL = 1;
		stcsr->max_size = 1;
                stcsr->size = 1;
		return SQLITE_OK;
            }
	    stcsr->isInstanceNULL = 0;
            any_dstr = (<%= sign_retype %>)stcsr->source;
<%        if @container_class.length > 0 %>
            if ((re = realloc_resultset(cur)) != SQLITE_OK) {
              return re;
            }
	    if (stcsr->isInstanceEmpty) return SQLITE_OK;
<%        else %>
	    stcsr->isInstanceEmpty = 0;
	    stcsr->max_size = 1;
<%        end %>
        }
        size = stcsr->max_size;
<%      end %>
        int *temp_res;
	temp_res = (int *)sqlite3_malloc(sizeof(int)  * size);
        if (!temp_res) {
            printf("Error in allocating memory\n");
            return SQLITE_NOMEM;
        }
