// Returns the size (records) for each virtual table.
size_t <%= @name %>_vt_get_datastructure_size (sqlite3_vtab_cursor *cur, sqlite3_vtab *vtab) {
  picoQLTable *picoQL = (picoQLTable *)vtab;
<%      if @container_class.length > 0 %>
  picoQL->object = 0;
<%# TODO carray support %>
<%        if @container_class == "carray" %>
  if (cur != NULL) {
    picoQLTableCursor *stc = (picoQLTableCursor *)cur;
<%          /\*/.match(@pointer) == nil ? retype = "*" : retype = "" %>
<%# stc->source will definitely hold a pointer so retyping the signature
<%# as follows is correct. %>
    <%= @signature %><%= retype %> any_dstr = (<%= @signature %><%= retype %>)stc->source;
<%          if $argD == "DEBUG" %>
#line <%= @signature_line + 1 %> "<%= $argF %>" 
<%          end %>
    return any_dstr-><%= vt.size %>;
  }
<%        end %>
<%      else %>
  (void)cur;
  picoQL->object = 1;
<%      end %>
  return 1;
}


void <%= @name %>_vt_init_result_set (sqlite3_vtab *vtab, sqlite3_vtab_cursor *cur) {
<%      if $lock.active == 1 && @container_class.length > 0 %>
  picoQLTable *picoQL = (picoQLTable *)vtab;
  if (!picoQL->locked)
    <%= $lock.lock_function %>;
  picoQL->locked += 1;
<%      else %>
  (void)vtab;
<%      end %>
  (void)cur;
}

int <%= @name %>_vt_advance_result_set_iter (sqlite3_vtab_cursor *cur, 
                                      struct Vtbl* vtbl) {
  picoQLTableCursor *stc = (picoQLTableCursor *)cur;
  cursor **cursors = ((<%= @name %>_vt *)vtbl)->cursors;
  size_t cursorsSize = ((<%= @name %>_vt *)vtbl)->cursorsSize;
  int j = 0;
<%    if @container_class.length > 0 %>
  ResultSet *res;
<%    end %>
  while ((j < (int)cursorsSize) && (cursors[j]->cur != cur)) {j++;}
  if (j == (int)cursorsSize) {
    printf("In <%= @name %>_vt_next_resultSet: Cursor %li not registered.\nExiting now.\n", (long int)cur);
    return SQLITE_ERROR;
  }
<%    if @container_class.length > 0 %>
  res = cursors[j]->res;
  if ((int)res->size > 0) {
    if (res->resultSetIterState == -1) {
      res->actualSize = res->size;
      res->offset = 0;
      res->resultSetIterState = 1;
    } else if (res->resultSetIterState == 1) {
      res->offset++;
    }
    while ((res->offset < res->size) && (((<%= @name %>ResultSetImpl *)res)->res[res->offset] == 0)) {res->offset++;}
    if (res->offset < res->size) {
#ifdef PICO_QL_DEBUG
      picoQLTable *st = (picoQLTable *)cur->pVtab;
      printf("Table %s, now res->offset: %i \nstc->isEof: %i\n\n", st->zName, res->offset, stc->isEof);
#endif
      return SQLITE_OK;
    }
  }
  stc->isEof = 1;
  res->size = 0;
  res->actualSize = 0;
  res->offset = -1;
  res->resultSetIterState = -1;
<%    else %>
  stc->offset++;
  if (stc->offset >= stc->size)
    stc->isEof = 1;
<%    end %>
#ifdef PICO_QL_DEBUG
  printf("Table %s, stc->isEof: %i\n\n", ((picoQLTable *)cur->pVtab)->zName, stc->isEof);
  printf("stc->offset: %i, stc->size: %i\n", stc->offset, stc->size);
#endif
  return SQLITE_OK;
}

void <%= @name %>_vt_deinit_result_set (sqlite3_vtab_cursor *cur, struct Vtbl *vtbl) {
  cursor **cursors = ((<%= @name %>_vt *)vtbl)->cursors;
  size_t cursorsSize = ((<%= @name %>_vt *)vtbl)->cursorsSize;
<%      if $lock.active == 1 && @container_class.length > 0 %>
  picoQLTable *picoQL = (picoQLTable *)cur->pVtab;
<%      end %>
<%      if @base_var.length == 0 %>
<%# need to malloc %>
  cursorCharged **charged = ((<%= @name %>_vt *)vtbl)->charged;
  size_t chargedSize = ((<%= @name %>_vt *)vtbl)->chargedSize;
  int i = 0;
<%      end %>
  int j = 0;
  while ((j < (int)cursorsSize) && (cursors[j]->cur != cur)) {j++;}
  if (j == (int)cursorsSize) {
    printf("In <%= @name %>_vt_deinit_resultSet: Cursor %li not registered.\n", (long int)cur);
  } else {
<%      if @container_class.length > 0 %>
    ResultSet *res = cursors[j]->res;
    sqlite3_free(((<%= @name %>ResultSetImpl *)res)->res);
    sqlite3_free((<%= @name %>ResultSetImpl *)res);
<%      end %>
    sqlite3_free(cursors[j]);
    cursors[j] = cursors[cursorsSize - 1];
    cursors[cursorsSize - 1] = NULL;
    ((<%= @name %>_vt *)vtbl)->cursorsSize--;
  }
<%      if @base_var.length == 0 %>
<%#  if (((<%= @name _vt *)vtbl)->cursorsSize == 0) { %>
  for (i = 0; i < (int)chargedSize; i++)
    sqlite3_free(charged[i]);
  ((<%= @name %>_vt *)vtbl)->chargedSize = 0;
  ((<%= @name %>_vt *)vtbl)->recursive = 0;
<%      end %>
<%      if $lock.active == 1 && @container_class.length > 0 %>
  if (picoQL->locked == 1)
    <%= $lock.unlock_function %>;
  picoQL->locked -= 1;
<%      end %>
}

<%    if @base_var.length == 0 %>

int <%= @name %>_report_charge (sqlite3_vtab_cursor *cur, int current, cursorCharged ***oCharged, size_t *oChargedSize, struct Vtbl *vtbl) {
  cursor **cursors = ((<%= @name %>_vt *)vtbl)->cursors;
  size_t cursorsSize = ((<%= @name %>_vt *)vtbl)->cursorsSize;
  cursorCharged **charged = ((<%= @name %>_vt *)vtbl)->charged;
  size_t chargedSize = ((<%= @name %>_vt *)vtbl)->chargedSize;
  int i = 0;
  if (current) {
    int j = 0;
    while ((j < (int)chargedSize) && (charged[j]->cur != cur)) {j++;}
    if (j == (int)chargedSize) {
      ((<%= @name %>_vt *)vtbl)->chargedSize++;
      chargedSize = ((<%= @name %>_vt *)vtbl)->chargedSize;
      cursorCharged *ch = sqlite3_malloc(sizeof(cursorCharged));
      if (ch == NULL)
        return SQLITE_NOMEM;
      ch->cur = cur;
      ch->flag = 0;
      ((<%= @name %>_vt *)vtbl)->charged = (cursorCharged **)sqlite3_realloc(((<%= @name %>_vt *)vtbl)->charged, sizeof(cursorCharged *)*chargedSize);
      if (((<%= @name %>_vt *)vtbl)->charged == NULL)
        return SQLITE_NOMEM;
      ((<%= @name %>_vt *)vtbl)->charged[chargedSize-1] = ch;
#ifdef PICO_QL_DEBUG
      printf("Table %s, chargedCursor: %li inserted, max size %i\n", picoQL->zName, (long int)cur, stcsr->max_size);
#endif
      if (oCharged != NULL) {
        j = 0;
        while (j < (int)*oChargedSize) {
          for (i = 0; i < (int)cursorsSize; i++) { 
            if (cursors[i]->cur == (*oCharged)[j]->cur) {
              if (!(*oCharged)[j]->flag) {
                ((<%= @name %>_vt *)vtbl)->recursive += 1;
                (*oCharged)[j]->flag = 1;
              }
            }
          }
          j++;
        }
      }
    }
  } else {
    for (i = 0; i < (int)chargedSize; i++)
      sqlite3_free(charged[i]);
    ((<%= @name %>_vt *)vtbl)->chargedSize = 0;
    ((<%= @name %>_vt *)vtbl)->recursive = 0;
  }
  return SQLITE_INTERNAL;
}

<%    end %>

void <%= @name %>_vt_discharge_saved_results (struct Vtbl *vtbl) {
<%      @columns.each { |col| %>
<%       if $argM == "MEM_MGT" && col.related_to.length > 0 && col.fk_method_ret == 1 %>
  sqlite3_free(((<%= @name %>_vt *)vtbl)->sr_<%= col.saved_results_index %>.captcha);
<%       end %>
<%      } %>
}

