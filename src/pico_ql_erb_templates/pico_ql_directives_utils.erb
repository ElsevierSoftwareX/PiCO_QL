/*
 *
 *   Automatically-generated file.  Do not modify.
 *   Modify pico_ql_directives_utils.erb and pico_ql_generator.rb
 *   instead.
 *
 *   Implement the filter and projection functions for
 *   each of the registered virtual tables.
 *
 *   Copyright 2012 Marios Fragkoulis
 *
 *   Licensed under the Apache License, Version 2.0
 *   (the "License");you may not use this file except in
 *   compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in
 *   writing, software distributed under the License is
 *   distributed on an "AS IS" BASIS.
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *   express or implied.
 *   See the License for the specific language governing
 *   permissions and limitations under the License.
 */

#include <cassert>
#include <cstdio>
#include <cstring>
#include <string>
#include <map>
#include <set>
#ifdef PICO_QL_HANDLE_POLYMORPHISM
#include <vector>
#endif
#include <list>
<%# list include..not always. At least on fk_col_type.length > 0 %>
#include <boost/concept_check.hpp>
#include <boost/dynamic_bitset.hpp>
#ifndef PICO_QL_SINGLE_THREADED
#include <pthread.h>
#endif
<%= directives %>
#include "pico_ql_search.h"
#include "pico_ql_internal.h"
#include "pico_ql_interface.h"
#include "pico_ql_search_helper.h"


using namespace std;
using namespace boost;
using namespace picoQL;

template <class T>
void forward_container_concept_check(T x) {
  BOOST_CONCEPT_ASSERT((ForwardContainer<T>));
  (void)x;
};

template <class It>
class forward_iterator_concept_class {
  BOOST_CONCEPT_ASSERT((ForwardIterator<It>));
};

// For the compiler to verify.
void check_concepts() {
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].container_class.length > 0 %>
<%# Chomp the pointer from signature. %>
<%# For non-pointers it will have zero effect. %>
  <%= @tables[vt].signature.chomp('*') %> container_instance<%= vt %>;
  forward_container_concept_check(container_instance<%= vt %>);
  forward_iterator_concept_class<<%= @tables[vt].signature.chomp('*') %>::iterator> it<%= vt %>;
  (void)it<%= vt %>;	// Silence compiler unused variable warning
 
<%      end %>
<%    } %>
}


struct name_cmp {
  bool operator()(const char *a, const char *b) {
    return strcmp(a, b) < 0;
  }
};

static map<string, VtblImpl*> selector_vt;

<%     i = 0 %>
<%     @tables.each { |vt| %>
<%      vt.columns.each { |col| %>
<%       if col.related_to.length > 0 && col.fk_method_ret == 1 %>
<%        col.fk_col_type = $table_index[col.related_to] %>
<%        if $argM == "MEM_MGT" %>
list <<%= col.fk_col_type.chomp('*') %> > saved_results_<%= i %>;
<%        end %>
<%        col.saved_results_index = i %>
<%        i += 1 %>
<%       end %>
<%      } %>
<%     } %>

<%     @tables.each { |vt| %>
<%      if vt.base_var.length > 0 %>
<%        /\*/.match(vt.pointer) == nil ? retype = "*" : retype = "" %>
<%        if $argD == "DEBUG" %>
// C NAME (pico_ql_table_)<%= vt.base_var %> in line <%= vt.base_var_line + 1 %> <%= $argF %> 
<%        end %>
static <%= vt.signature %> <%= retype %>pico_ql_table_<%= vt.base_var %> = NULL;
<%        if $argD == "DEBUG" %>
#line <%= vt.signature_line + 1 %> "<%= $argF %>" 
<%        end %>
<%      end %>
<%     } %>


/* Registers the base variables of user application code
 * with PiCO QL.
 */
void picoQL::pico_ql_register(const void *data_structure, const char *ds_name) {
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].base_var.length > 0 %>
<%        if count == 0 %>
  if (!strcmp(ds_name, "<%= @tables[vt].base_var %>")) {
<%	  count += 1 %>
<%        else %>
  } else if (!strcmp(ds_name, "<%= @tables[vt].base_var %>")) {
<%        end %>
<%        if $argD == "DEBUG" %>
#line <%= @tables[vt].base_var_line + 1 %> "<%= $argF %>" 
<%        end %>
<%        /\*/.match(@tables[vt].pointer) == nil ? retype = "*" : retype = "" %>
    pico_ql_table_<%= @tables[vt].base_var %> = (<%= @tables[vt].signature %> <%= retype %>)data_structure;
<%        if $argD == "DEBUG" %>
#line <%= @tables[vt].signature_line + 1 %> "<%= $argF %>" 
<%        end %>
<%      end %>
<%    } %>
  }
}

// Thread. Creates the queries and passes them on to PiCO_QL.
void * thread_sqlite(void *data) {
  const char **queries, **table_names;
  queries = (const char **)sqlite3_malloc(sizeof(char *) * <%= @tables.length.to_s %>);
  table_names = (const char **)sqlite3_malloc(sizeof(char *) * <%= @tables.length.to_s %>);
  int failure = 0;
<%# <db>.<table> does not work for some reason. test. %>
<%# counter %>
<%    @tables.each_index { |vt| %>
<%#     query =  "CREATE VIRTUAL TABLE #{@tables[vt].db}.#{@tables[vt].name} USING PicoQL(" %>
<%      query =  "CREATE VIRTUAL TABLE #{@tables[vt].name} USING PicoQL(" %>
<%      @tables[vt].columns.each { |c| %>
<%        query += "#{c.name} #{c.data_type}, " %>
<%      } %>
<%      query = query.chomp(", ") + ")" %>
  queries[<%= vt %>] = "<%= query %>";
  table_names[<%= vt %>] = "<%= @tables[vt].name %>";
<%    } %>
<%#    @views.each_index { |vs| %>
<%#  queries[<%= vs ] = "<%= @views[vs] "; %>
<%#    } %>
  set_selectors();
  int port_number = *(int *)data;
  delete (int *)data;
  failure = register_table( "<%= @tables[0].db %>" , <%= @tables.length.to_s %>,  queries, table_names, port_number);
  printf("Thread sqlite returns %i\n", failure);
  sqlite3_free(queries);
  sqlite3_free(table_names);
  return NULL;
}


// The API with user application code. Creates the PiCO_QL thread.
int picoQL::pico_ql_serve(int port) {
  int *portN = new int(port);
#ifndef PICO_QL_SINGLE_THREADED
  pthread_t sqlite_thread;
  pthread_create(&sqlite_thread, NULL, thread_sqlite, (void *)portN);
#ifdef PICO_QL_JOIN_THREADS
  pthread_join(sqlite_thread, NULL);
#endif
#else
  thread_sqlite((void *)portN);
#endif
  return 0;
}


/* Registers the base variables of user application code
 * with their virtual table representation.
 */
int picoQL::register_vt(picoQLTable *picoQL) {
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].base_var.length > 0 %>
<%        if count == 0 %>
  if (!strcmp(picoQL->zName, "<%= @tables[vt].name %>")) {
<%	  count += 1 %>
<%        else %>
  } else if (!strcmp(picoQL->zName, "<%= @tables[vt].name %>")) {
<%        end %>
<%# Retyping has been taken care of in register_pico_ql %>
<%#        /\*/.match(@tables[vt].pointer) == nil ? retype = "&" : retype = "" %>
<%        if $argD == "DEBUG" %>
#line <%= @tables[vt].base_var_line + 1 %> "<%= $argF %>" 
<%        end %>
    if (pico_ql_table_<%= @tables[vt].base_var %> == NULL)
      return SQLITE_ERROR;
    picoQL->data = (void *)pico_ql_table_<%= @tables[vt].base_var %>;
    picoQL->embedded = 0;
<%      end %>
<%    } %>
  } else {
    picoQL->data = NULL;
    picoQL->embedded = 1;
  }
  return SQLITE_INTERNAL;
}


// Each embedded virtual table has a column named 'base'.
// This function checks if a provided column name is indeed 'base'.
int picoQL::equals(const char *zCol, const char *key) {
  int length = (int)strlen(zCol) + 1;
  char copy[length], *token;
  memcpy(copy, zCol, length);
  token = strtok(copy, " ");
  if (token != NULL) {
    if (!strcmp(token, key))
      return true;
    else
      return false;
  } else
    return SQLITE_NOMEM;
}


/* Initiates dynamic vector which stores resultset column
 * values of type char array so that they are retrievable
 * by SQLite without conflict.
 */
int picoQL::init_text_vector(picoQLTableCursor *stc) {
#ifdef PICO_QL_HANDLE_POLYMORPHISM
  vector<string*> *tr = new vector<string*>();
  stc->textResults = (void *)tr;
  if (tr != NULL)
    return SQLITE_OK;
  else
    return SQLITE_NOMEM;
#endif
  return SQLITE_OK;
}


/* Deinitiates dynamic vector which stores resultset
 * column values of type char array so that they are
 * retrievable by SQLite without conflict.
 */
void picoQL::deinit_text_vector(picoQLTableCursor *stc) {
#ifdef PICO_QL_HANDLE_POLYMORPHISM
  vector<string*> *tr = (vector<string*> *)stc->textResults;
  for (size_t i = 0; i < tr->size(); i++)
    delete tr->at(i);
  delete tr;
#endif
}


/* Deinitiates vectors which store temporary FK
 * column values so that they are
 * manageable by SQLite safely.
 */
void picoQL::deinit_temp_structs() {
<%     @tables.each { |vt| %>
<%      vt.columns.each { |col| %>
<%       if $argM == "MEM_MGT" && col.related_to.length > 0 && col.fk_method_ret == 1 %>
  saved_results_<%= col.saved_results_index %>.clear();
<%       end %>
<%      } %>
<%      if vt.base_var.length == 0 %>
  map<sqlite3_vtab_cursor *, bool> *map<%= vt.name %>;
  map<%= vt.name %> = NULL;
  VtblImpl *discharge<%= vt.name %>VT = selector_vt["<%= vt.name %>"];
  (*discharge<%= vt.name %>VT)(NULL, 0, map<%= vt.name %>);
<%      end %>
<%     } %>
}

/* Deinitiates map which stores pairs of
 * virtual table names to functors virtualizing
 * individual VT search/retrieve implementations.
 */
void picoQL::deinit_vt_selectors() {
  map<string, VtblImpl *>::iterator it;
  for (it = selector_vt.begin(); it != selector_vt.end(); it++)
    delete it->second;
}

namespace picoQL {
<%     @tables.each { |vt| %>
class <%= vt.name %>_vt : public VtblImpl {
private:
<%      if vt.container_class.length > 0 %>
  class ResultSet {
  public:
    vector<<%= vt.signature.chomp('*') %>::iterator> res;
    vector<<%= vt.signature.chomp('*') %>::iterator>::iterator resIter;
    dynamic_bitset<unsigned long> resBts;
    int resultSetIterState;
    int current;
    ResultSet(int res_max_size, int resIterState, int cur, vector<<%= vt.signature.chomp('*') %>::iterator>::iterator it) {
      resBts.resize(res_max_size);
      resultSetIterState = resIterState;
      current = cur;
      resIter = it;
    };
    ResultSet() {};
    ~ResultSet() {resBts.clear();};
  };
  map<sqlite3_vtab_cursor *, ResultSet> cursors;
  vector<<%= vt.signature.chomp('*') %>::iterator>::iterator resIterC;
  <%= vt.signature.chomp('*') %>::iterator iter;
<%      else %>
  set<sqlite3_vtab_cursor *> cursors;
<%      end %>
<%      if vt.base_var.length == 0 %>
  map<sqlite3_vtab_cursor *, bool> charged;
  int recursive;
<%      end %>
public:
  <%= vt.name %>_vt() : VtblImpl() {
<% if vt.base_var.length == 0 %>    recursive = 0;<% end %>};
  virtual int operator() (sqlite3_vtab_cursor *, int,
                    int, sqlite3_value *);
  virtual int operator() (sqlite3_vtab_cursor *,
                    int, sqlite3_context *);
  virtual size_t operator() (sqlite3_vtab_cursor *, sqlite3_vtab *);
  virtual int operator() (sqlite3_vtab_cursor *);
  virtual void operator() (sqlite3_vtab_cursor *, void *);
  virtual void operator() (sqlite3_vtab *, sqlite3_vtab_cursor *);
<%      if vt.base_var.length == 0 %>
  virtual void operator() (sqlite3_vtab_cursor *cur, int current, map<sqlite3_vtab_cursor *, bool> *oCharged) {
    pair<map<sqlite3_vtab_cursor *, bool>::iterator, bool> operation;
    if (current) {
      operation = charged.insert(pair<sqlite3_vtab_cursor *, bool>(cur, false));
      if ((operation.second) && (oCharged != NULL)) {
        map<sqlite3_vtab_cursor *, bool>::iterator iter;
        for (iter = oCharged->begin(); iter != oCharged->end(); iter++) {
          if (cursors.find(iter->first) != cursors.end()) {
            if (!iter->second) {
              recursive += 1;
              iter->second = true;
            }
          }
        }
      }
    } else {
      charged.clear();
      recursive = 0;
    }
  };
<%      else %>
  virtual void operator() (sqlite3_vtab_cursor *, int, map<sqlite3_vtab_cursor *, bool> *) {};
<%      end %>

};
 
<%     } %>
 
 
