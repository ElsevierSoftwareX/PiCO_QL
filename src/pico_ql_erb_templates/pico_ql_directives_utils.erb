/*
 *
 *   Automatically-generated file.  Do not modify.
 *   Modify pico_ql_directives_utils.erb and pico_ql_generator.rb
 *   instead.
 *
 *   Implement the filter and projection functions for
 *   each of the registered virtual tables.
 *
 *   Copyright 2012 Marios Fragkoulis
 *
 *   Licensed under the Apache License, Version 2.0
 *   (the "License");you may not use this file except in
 *   compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in
 *   writing, software distributed under the License is
 *   distributed on an "AS IS" BASIS.
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *   express or implied.
 *   See the License for the specific language governing
 *   permissions and limitations under the License.
 */

#include <cassert>
#include <cstdio>
#include <cstring>
#include <string>
#include <map>
#ifdef PICO_QL_HANDLE_POLYMORPHISM
#include <vector>
#endif
#include <list>
<%# list include..not always. At leaston fk_col_type.length > 0 %>
#include <boost/concept_check.hpp>
#ifndef PICO_QL_SINGLE_THREADED
#include <pthread.h>
#endif
<%= directives %>
#include "pico_ql_search.h"
#include "pico_ql_internal.h"
#include "pico_ql_interface.h"
#include "pico_ql_search_helper.h"


using namespace std;
using namespace boost;
using namespace picoQL;

template <class T>
void forward_container_concept_check(T x) {
    BOOST_CONCEPT_ASSERT((ForwardContainer<T>));
};

template <class It>
class forward_iterator_concept_class {
    BOOST_CONCEPT_ASSERT((ForwardIterator<It>));
};

// For the compiler to verify.
void check_concepts() {
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].container_class.length > 0 %>
<%# Chomp the pointer from signature. %>
<%# For non-pointers it will have zero effect. %>
  <%= @tables[vt].signature.chomp('*') %> container_instance<%= vt %>;
  forward_container_concept_check(container_instance<%= vt %>);
  forward_iterator_concept_class<<%= @tables[vt].signature.chomp('*') %>::iterator> it<%= vt %>;
  (void)it<%= vt %>;	// Silence compiler unused variable warning
 
<%      end %>
<%    } %>
}


struct name_cmp {
    bool operator()(const char *a, const char *b) {
        return strcmp(a, b) < 0;
    }
};

static map<string, FunctoryVT*> selector_vt;

<%     i = 0 %>
<%     @tables.each { |vt| %>
<%      vt.columns.each { |col| %>
<%       if col.related_to.length > 0 && col.access_path.match(/(.+)\)/) %>
<%        col.fk_col_type = $table_index[col.related_to] %>
list <<%= col.fk_col_type.chomp('*') %> > saved_results_<%= i %>;
<%        col.saved_results_index = i %>
<%        i += 1 %>
<%       end %>
<%      } %>
<%     } %>

<%     @tables.each { |vt| %>
<%      if vt.base_var.length > 0 %>
<%        /\*/.match(vt.pointer) == nil ? retype = "*" : retype = "" %>
<%        if $argD == "DEBUG" %>
// C NAME (pico_ql_table_)<%= vt.base_var %> in line <%= vt.base_var_line + 1 %> <%= $argF %> 
<%        end %>
static <%= vt.signature %> <%= retype %>pico_ql_table_<%= vt.base_var %> = NULL;
#line <%= vt.signature_line + 1 %> "<%= $argF %>" 
<%      end %>
<%     } %>

/* Registers the base variables of user application code
 * with PiCO QL.
 */
void picoQL::pico_ql_register(const void *data_structure, const char *ds_name) {
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].base_var.length > 0 %>
<%        if count == 0 %>
    if (!strcmp(ds_name, "<%= @tables[vt].base_var %>")) {
<%	  count += 1 %>
<%        else %>
    } else if (!strcmp(ds_name, "<%= @tables[vt].base_var %>")) {
<%        end %>
#line <%= @tables[vt].base_var_line + 1 %> "<%= $argF %>" 
<%        /\*/.match(@tables[vt].pointer) == nil ? retype = "*" : retype = "" %>
        pico_ql_table_<%= @tables[vt].base_var %> = (<%= @tables[vt].signature %> <%= retype %>)data_structure;
#line <%= @tables[vt].signature_line + 1 %> "<%= $argF %>" 
<%      end %>
<%    } %>
    }
}

// Thread. Creates the queries and passes them on to PiCO_QL.
void * thread_sqlite(void *data) {
    const char **queries, **table_names;
    queries = (const char **)sqlite3_malloc(sizeof(char *) *
                   <%= @tables.length.to_s %>);
    table_names = (const char **)sqlite3_malloc(sizeof(char *) *
                   <%= @tables.length.to_s %>);
    int failure = 0;
<%# <db>.<table> does not work for some reason. test. %>
<%    @tables.each_index { |vt| %>
<%#     query =  "CREATE VIRTUAL TABLE #{@tables[vt].db}.#{@tables[vt].name} USING PicoQL(" %>
<%      query =  "CREATE VIRTUAL TABLE #{@tables[vt].name} USING PicoQL(" %>
<%      @tables[vt].columns.each { |c| %>
<%        query += "#{c.name} #{c.data_type}, " %>
<%      } %>
<%      query = query.chomp(", ") + ")" %>
    queries[<%= vt %>] = "<%= query %>";
    table_names[<%= vt %>] = "<%= @tables[vt].name %>";
<%    } %>
    set_selectors();
    int port_number = *(int *)data;
    failure = register_table( "<%= @tables[0].db %>" , <%= @tables.length.to_s %>, queries, table_names, port_number);
    printf("Thread sqlite returns %i\n", failure);
    sqlite3_free(queries);
    sqlite3_free(table_names);
    return NULL;
}


// The API with user application code. Creates the PiCO_QL thread.
int picoQL::pico_ql_serve(int port_number) {
#ifndef PICO_QL_SINGLE_THREADED
    pthread_t sqlite_thread;    
    pthread_create(&sqlite_thread, NULL, thread_sqlite, (void *)&port_number);
#ifdef PICO_QL_JOIN_THREADS
    pthread_join(sqlite_thread, NULL);
#endif
#else
    thread_sqlite((void *)&port_number);
#endif
    return 0;
}


/* Registers the base variables of user application code
 * with their virtual table representation.
 */
int picoQL::register_vt(picoQLTable *picoQL) {
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].base_var.length > 0 %>
<%        if count == 0 %>
    if (!strcmp(picoQL->zName, "<%= @tables[vt].name %>")) {
<%	  count += 1 %>
<%        else %>
    } else if (!strcmp(picoQL->zName, "<%= @tables[vt].name %>")) {
<%        end %>
<%# Retyping has been taken care of in register_pico_ql %>
<%#        /\*/.match(@tables[vt].pointer) == nil ? retype = "&" : retype = "" %>
#line <%= @tables[vt].base_var_line + 1 %> "<%= $argF %>" 
	if (pico_ql_table_<%= @tables[vt].base_var %> == NULL)
	    return SQLITE_ERROR;
        picoQL->data = (void *)pico_ql_table_<%= @tables[vt].base_var %>;
        picoQL->embedded = 0;
<%      end %>
<%    } %>
    } else {
        picoQL->data = NULL;
        picoQL->embedded = 1;
    }
    return SQLITE_INTERNAL;
}

// Returns the size (records) for each virtual table.
int picoQL::get_datastructure_size(sqlite3_vtab_cursor *cur) {
    picoQLTableCursor *stc = (picoQLTableCursor *)cur;
    picoQLTable *picoQL = (picoQLTable *)cur->pVtab;
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].container_class.length > 0 %>
<%        if count == 0 %>
    if (!strcmp(picoQL->zName, "<%= @tables[vt].name %>")) {
<%	  count += 1 %>
<%        else %>
    } else if (!strcmp(picoQL->zName, "<%= @tables[vt].name %>")) {
<%        end %>
<%        /\*/.match(@tables[vt].pointer) == nil ? retype = "*" : retype = "" %>
<%# stc->source will definitely hold a pointer so retyping the signature as
<%# follows is correct. %>
        <%= @tables[vt].signature %><%= retype %> any_dstr = (<%= @tables[vt].signature %><%= retype %>)stc->source;
#line <%= @tables[vt].signature_line + 1 %> "<%= $argF %>" 
        return (int)any_dstr->size();
<%      end %>
<%    } %>
    }
    picoQL->object = 1;
    return 1;
}


// Each embedded virtual table has a column named 'base'.
// This function checks if a provided column name is indeed 'base'.
int picoQL::equals(const char *zCol, const char *key) {
    int length = (int)strlen(zCol) + 1;
    char copy[length], *token;
    memcpy(copy, zCol, length);
    token = strtok(copy, " ");
    if (token != NULL) {
        if (!strcmp(token, key))
            return true;
        else
            return false;
    } else
        return SQLITE_NOMEM;
}




/* Initiates dynamic vector which stores resultset column
 * values of type char array so that they are retrievable
 * by SQLite without conflict.
 */
int picoQL::init_text_vector(picoQLTableCursor *stc) {
#ifdef PICO_QL_HANDLE_POLYMORPHISM
  vector<string*> *tr = new vector<string*>();
  stc->textResults = (void *)tr;
  if (tr != NULL)
    return SQLITE_OK;
  else
    return SQLITE_NOMEM;
#endif
  return SQLITE_OK;
}


/* Deinitiates dynamic vector which stores resultset
 * column values of type char array so that they are
 * retrievable by SQLite without conflict.
 */
void picoQL::deinit_text_vector(picoQLTableCursor *stc) {
#ifdef PICO_QL_HANDLE_POLYMORPHISM
  vector<string*> *tr = (vector<string*> *)stc->textResults;
  for (size_t i = 0; i < tr->size(); i++)
      delete tr->at(i);
  delete tr;
#endif
}


/* Deinitiates vectors which store temporary FK
 * column values so that they are
 * manageable by SQLite safely.
 */
void picoQL::deinit_temp_structs() {
<%     @tables.each { |vt| %>
<%      vt.columns.each { |col| %>
<%       if col.fk_col_type.length > 0 %>
  saved_results_<%= col.saved_results_index %>.clear();
<%       end %>
<%      } %>
<%      if vt.base_var.length == 0 %>
  VtblImpl *dischargeVT<%= col %> = selector_vt["<%= vt.name %>"];
  (*dischargeVT<%= col %>)(0);
<%     } %>
}

/* Deinitiates map which stores pairs of
 * virtual table names to functors virtualizing
 * individual VT search/retrieve implementations.
 */
void picoQL::deinit_vt_selectors() {
  map<string, FunctoryVT *>::iterator it;
  for (it = selector_vt.begin(); it != selector_vt.end(); it++)
    delete it->second;
}

namespace picoQL {
<%     @tables.each { |vt| %>
class <%= vt.name %>_vt : public VtblImpl {
<%      if @tables[vt].container_class.length > 0 %>
private:
  vector<<%= @tables[vt].signature.chomp('*') %>::iterator>::iterator resIter;
  vector<<%= @tables[vt].signature.chomp('*') %>::iterator>::iterator resIterL;
  vector<<%= @tables[vt].signature.chomp('*') %>::iterator>::iterator resIterT;
  <%= @signature.chomp('*') %>::iterator iter;
  <%= @signature.chomp('*') %>::iterator iterL;
<%      end %>
<%      if @tables[vt].base_var.length == 0 %>
  int charged;
<%      end %>
public:
  <%= vt.name %>_vt() : VtblImpl() {};
  virtual int operator() (sqlite3_vtab_cursor *, int,
                    int, sqlite3_value *);
  virtual int operator() (sqlite3_vtab_cursor *,
                    int, sqlite3_context *);
<%      if @tables[vt].container_class.length > 0 %>
  virtual void operator() (picoQLTable *, picoQLTableCursor *);

  virtual int operator() (picoQLTableCursor *);

  virtual void operator() (picoQLTableCursor *);
<%      else %>
  virtual void operator() (picoQLTable *, picoQLTableCursor *) {};
  
  virtual int operator() (picoQLTableCursor *)
  {return SQLITE_ERROR;};

  virtual void operator() (picoQLTableCursor *) {};
<%      end %>
<%      if @tables[vt].base_var.length == 0 %>
  virtual void operator() (int) {charged = current;};
<%      else %>
  virtual void operator() (int) {};
<%      end %>

};
 
<%     } %>
 
 
