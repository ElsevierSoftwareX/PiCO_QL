\documentclass[pdftex, 11pt, a4paper]{report}
\usepackage[pdftex]{graphicx}                % See geometry.pdf to learn the layout options. There are lots.
\usepackage{setspace}
\usepackage[greek, english]{babel}
\usepackage{appendix}
\usepackage{url}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
%\pdfpagewidth 8.5in
%\pdfpageheight 11in
\topmargin -1cm
\oddsidemargin 0.7cm
\evensidemargin 0.55cm
\textwidth 14cm
\textheight 24cm
%\linespread{1}

\onehalfspacing

\renewcommand{\baselinestretch}{1.4}


\usepackage{sectsty}
\chapterfont{\Huge}
\sectionfont{\LARGE}
\subsectionfont{\Large}

\makeatletter
\newcommand\ackname{Acknowledgements}
\if@titlepage
  \newenvironment{acknowledgements}{%
      \titlepage
      \null\vfil
      \@beginparpenalty\@lowpenalty
      \begin{center}%
        \bfseries \ackname
        \@endparpenalty\@M
      \end{center}}%
     {\par\vfil\null\endtitlepage}
\else
  \newenvironment{acknowledgements}{%
      \if@twocolumn
        \chapter*{\abstractname}%
      \else
        \small
        \begin{center}%
          {\bfseries \ackname\vspace{-.5em}\vspace{\z@}}%
        \end{center}%
        \quotation
      \fi}
      {\if@twocolumn\else\endquotation\fi}
\fi
\makeatother



\begin{document}

\begin{titlepage}
\begin{center}
\topskip 3cm
\HRule \\[0.4 cm]
\textsc{\Huge A relational view}\\[0.5 cm]
\textsc{\Huge of non-relational}\\[0.5 cm]
\textsc{\Huge data}\\[0.5 cm]
\textsc{\Huge }
\HRule \\[2.0 cm]
\textsc{\LARGE Marios Fragkoulis}\\[3.0 cm]
\textsc{\LARGE Supervisor: Dr. Diomidis Spinellis}\\[2.0 cm]
\textsc{\Large \today}                                           % Activate to display a given date or no date

\vspace{3.5 cm}

\begin{minipage}{0.4\linewidth}
\begin{flushleft} \large
\it{Athens University of Economics and Business}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{flushright} \large
\it{Department of Management Science and Technology}
\end{flushright}
\end{minipage}

\vfill

\end{center}
\end{titlepage}

%\begin{document}
%\maketitle 
%\newpage


\parindent 6mm
\parskip 0.2cm


\begin{abstract}

\end{abstract}

\topmargin 0.5cm
\textheight 21cm

\newpage

\begin{acknowledgements}



\end{acknowledgements}

\newpage


\tableofcontents

\newpage


\chapter{Introduction}
\par


\section{Motivation}
\par


\section{Approach}
\par
To provide the service of monitoring data structures of the Standard Template Library (STL) a relational interpretation of the data structure is built. Hence, we need to address the impedance mismatch problem which exists between the Object Oriented (OO) and the relational model. On this road, we use the Virtual Table API of the Sqlite open source database engine to map the data structure to a virtual table and then the well known query facilities of SQL to retrieve information, treating it as a database table. Finally, the SWILL library is utilized to provide user with a cosy interface to write queries and visualize the respective results.
\par
Sqlite's virtual table API allows us to define a module stating the characteristics it will bear and the methods used to access the underlying structure. Those methods are assigned to function pointers included in the module struct, called by the sqlite engine when a respective job has to be performed on the virtual table. Effectively, the idiosyncrasies of the item behind the virtual table are well hidden. It is this abstraction layer that makes our goal plausible.
\par
However, to retrieve information from a data structure through the virtual table mechanism is no easy task. What makes this matter complex is that a data structure can store simply anything, since the class template can be instantiated by passing a user defined class as a template argument. The effect incurred is that we cannot write generic code to realize the services in request because the possibilities are endless. On the contrary, we are obliged to act on a case to case basis vis-a-vis the specific instantiation of the data structure.
\par
Once a query has been input to execute against the virtual table, the sqlite engine issues calls to respective callback methods of the module the virtual table is registered with, to initiate search on the underlying structure. Search can not be carried out without knowing the structure of the object hosted by the data structure. The same applies to result retrieval. Therefore, it is requisite to be given a description of the object included in the container so that callback methods can be parameterized respectively. 
\par
Furthermore, the callback methods are tuned with respect to user description via automatic code generation. User supplies all necessary data to a program written in ruby language. Data are processed, code is generated and written to a C++ file fulfilling the functionality of callback methods. A sample main function is also generated for the user to fill in own functionality. Then the files have to be compiled with user defined classes. The executable incurred opens a thread, registers the module with a database connection against a database file the user has opted for, creates the virtual table using the module and prompts user to open his browser at localhost where SWILL library masqueraded as a web server allows him to write and execute queries using the open database connection.
\par
In more detail...
\par
As mentioned above, a description of the data structure is necessary to make the approach functional. This description is transformed to a set of C++ functions, to be incorporated to the module, by a program written in the ruby language. To be precise, the description given falls under certain rules so that it can be parsed and analyzed. It includes the name of the database file to create the virtual table and any number of data structure descriptions. A data structure is fully described by providing its name (to name the virtual table after), the way the object is provided (object or pointer), its signature (container class and template arguments) and finally the description(s) of the template argument(s). The latter encloses the class name and the names and types of the attributes. Relationships between classes and inheritance hierarchies are accounted for together with the possibility of embedded data structures. In a nutshell, it is a simple language with delimiters and keywords to address all aforementioned matters.
\par
Delimiters are used to break down the description to discrete analyzable parts. The name of the database and subsequent data structure descriptions are separated by exclamation marks (!). Data structure name, object type, signature and the description(s) of template argument(s) are parsed by interposing a (;). A template argument description contains the description of one or more classes which are separated by means of a (:). Class descriptions contain attributes sorted out by a (-). Finally, each attribute is represented as a pair of data type and name. The two of them are earmarked by a comma (,).
\par
Keywords of the language include ds, ds\_pointer, class, class\_pointer, reference and inherits\_from. Keywords are utilized inside attribute representations and specifically as data types to pinpoint particular semantics. If ds is encountered then the current attribute of the class included in a template argument is an embedded data structure while ds\_pointer means that there is a pointer to a data structure at that position. Moreover, its pair will be treated as the name of the data structure and will be used as identification to track its description later on. Similarly, class and class pointer are the first keywords to be met at a class description. Next to the keyword the name of the class is anticipated. When a class contains a reference to another class, the keyword reference is used followed by the name of the latter. Again, the name is utilized to recover the description of the class which is expected to follow inside the same template argument description. Keyword inherits\_from signifies that there is an inheritance relationship. It is expected to be met next to the class or class\_pointer keyword. As before, description of the super class is awaited further on in the same template argument description.
\par
Once the ruby program starts executing it analyzes the user description. If the delimiters and keywords do not fall into place then informative error messages are produced and the program exits. Alternatively, a complex data structure is utilized to keep all that information in a convenient fashion. 
\par
The data structure is an array of complex objects of the Hash class. Each Hash object contains the total information about an STL data structure. The key of the Hash object contains an object of an internally used class and includes attributes name, type, signature, template1\_type and template2\_type. Template1\_type and template2\_type take values none, primitive, user\_simple and complex. They are utilized to achieve the proper transformations and direct the operations respectively when generating code. The second template argument of the Hash object contains yet another Hash object. The two constituents of the latter are actually the template arguments description. Each of the above contain one more Hash object keeping the class definitions by means of string, for the class name and Array of strings, for the class attributes.
\par
The program's agenda includes preparing the calls to sqlite to create the virtual tables. The calls comprise sql "create table" queries. To this end, create\_vt function is called to create those queries. Hence, the information stored in the aforementioned data structure is needed. Each record in the array will conform to a "create table" query. The concept is to reserve a column for each attribute found at both template arguments descriptions resulting in a flat format. The process is not straightforward. Not all attributes will represent primitive data types. Consequently, this brings us back to the discussion about keywords.
\par
Function recursive\_traversal takes as input the total of a class attributes starting from the one found at the signature of the data structure. It loops through its attributes and for each one of them calls function neat\_attributes. The latter processes the data type and if it is of primitive type it returns the attribute as is. If it is a keyword it makes the necessary amendments. Keywords ds and ds\_pointer incur a "references" directive which instructs sqlite to create a foreign key relationship. Since we are talking about an embedded data structure, as afore explained, we need a way to refer to the other data structure from the present one. Each data structure in our model is represented by a virtual table, hence the foreign key relationship is a handy solution. The other keywords concern either an inheritance relationship or a reference to an object of another class. Either way a "jump" is improvised to go to the description of the referenced class or superclass. Once done with that, a jump back is carried out. 

\end{document}