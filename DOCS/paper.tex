\documentclass[pdftex, 11pt, a4paper]{report}
\usepackage[pdftex]{graphicx}                % See geometry.pdf to learn the layout options. There are lots.
\usepackage{setspace}
\usepackage[greek, english]{babel}
\usepackage{appendix}
\usepackage{url}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
%\pdfpagewidth 8.5in
%\pdfpageheight 11in
\topmargin -1cm
\oddsidemargin 0.7cm
\evensidemargin 0.55cm
\textwidth 14cm
\textheight 24cm
%\linespread{1}

\onehalfspacing

\renewcommand{\baselinestretch}{1.4}


\usepackage{sectsty}
\chapterfont{\Huge}
\sectionfont{\LARGE}
\subsectionfont{\Large}

\makeatletter
\newcommand\ackname{Acknowledgements}
\if@titlepage
  \newenvironment{acknowledgements}{%
      \titlepage
      \null\vfil
      \@beginparpenalty\@lowpenalty
      \begin{center}%
        \bfseries \ackname
        \@endparpenalty\@M
      \end{center}}%
     {\par\vfil\null\endtitlepage}
\else
  \newenvironment{acknowledgements}{%
      \if@twocolumn
        \chapter*{\abstractname}%
      \else
        \small
        \begin{center}%
          {\bfseries \ackname\vspace{-.5em}\vspace{\z@}}%
        \end{center}%
        \quotation
      \fi}
      {\if@twocolumn\else\endquotation\fi}
\fi
\makeatother



\begin{document}

\begin{titlepage}
\begin{center}
\topskip 3cm
\HRule \\[0.4 cm]
\textsc{\Huge A relational view}\\[0.5 cm]
\textsc{\Huge of non-relational}\\[0.5 cm]
\textsc{\Huge data}\\[0.5 cm]
\textsc{\Huge }
\HRule \\[2.0 cm]
\textsc{\LARGE Marios Fragkoulis}\\[3.0 cm]
\textsc{\LARGE Supervisor: Dr. Diomidis Spinellis}\\[2.0 cm]
\textsc{\Large \today}                                           % Activate to display a given date or no date

\vspace{3.5 cm}

\begin{minipage}{0.4\linewidth}
\begin{flushleft} \large
\it{Athens University of Economics and Business}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{flushright} \large
\it{Department of Management Science and Technology}
\end{flushright}
\end{minipage}

\vfill

\end{center}
\end{titlepage}

%\begin{document}
%\maketitle 
%\newpage


\parindent 6mm
\parskip 0.2cm


\begin{abstract}

\end{abstract}

\topmargin 0.5cm
\textheight 21cm

\newpage

\begin{acknowledgements}



\end{acknowledgements}

\newpage


\tableofcontents

\newpage


\chapter{Introduction}
\par


\section{Motivation}
\par


\section{Approach}
\par
% idea-concept
To provide the service of monitoring data structures of the Standard Template Library (STL) a relational interpretation of the data structure is built. Hence, we need to address the impedance mismatch problem which exists between the Object Oriented (OO) and the relational model. On this road, we use the Virtual Table API of the Sqlite open source database engine to map the data structure to a virtual table and then the well known query facilities of SQL to retrieve information, treating it as a database table. Finally, the SWILL library is utilized to provide user with a cosy interface to write queries and visualize the respective results.
\par
% strategy - how do we do it
Sqlite's virtual table API allows us to define a module stating the characteristics it will bear and the methods used to access the underlying structure. Those methods are assigned to function pointers included in the module struct, called by the sqlite engine when a respective job has to be performed on the virtual table. Effectively, the idiosyncrasies of the item behind the virtual table are well hidden. It is this abstraction layer that makes our goal plausible.
\par
% the how - going lower - technique (why difficult?)
However, to retrieve information from a data structure through the virtual table mechanism is no easy task. What makes this matter complex is that a data structure can store simply anything, since the class template can be instantiated by passing a user defined class as a template argument. The effect incurred is that we cannot write generic code to realize the services in request because the possibilities are endless. On the contrary, we are obliged to act on a case to case basis vis-a-vis the specific instantiation of the data structure.
\par
% describing the difficulty
Once a query has been input to execute against the virtual table, the sqlite engine issues calls to respective callback methods of the module the virtual table is registered with, to initiate search on the underlying structure. Search can not be carried out without knowing the structure of the object hosted by the data structure. The same applies to result retrieval. Therefore, it is requisite to be given a description of the object included in the container so that callback methods can be parameterized respectively. 
\par
% how do we address the issue - high level
The callback methods are tuned with respect to user description via automatic code generation. User supplies all necessary data to a program written in ruby language. Data are processed, code is generated and written to a C++ file fulfilling the functionality of callback methods. A sample main function is also generated for the user to fill in own functionality. Then the files have to be compiled with user defined classes. The executable incurred opens a thread, registers the module with a database connection against a database file the user has opted for, creates the virtual table using the module and prompts user to open his browser at localhost where SWILL library masqueraded as a web server allows him to write and execute queries using the open database connection.
\par
In more detail...
\par
% how do we address the issue - lower level
As mentioned above, a description of the data structure is necessary to make the approach functional. This description is transformed to a set of C++ functions, to be incorporated to the module, by a program written in the ruby language. To be precise, the description given falls under certain rules so that it can be parsed and analyzed. It includes the name of the database file to create the virtual table and any number of data structure descriptions. A data structure is fully described by providing its name (to name the virtual table after), the way the object is provided by the user (object or pointer), its signature (container class and template arguments) and finally the description(s) of the template argument(s). The latter encloses the class name and the names and types of the attributes. Since a class may contain references to other classes, any number of class descriptions can coexist in a template argument description. Hence, relationships between classes and inheritance hierarchies are accounted for together with the possibility of embedded data structures. In a nutshell, it is a simple language with delimiters and keywords to address all aforementioned matters.
\par
% continuing...
Delimiters are used to break down the description to discrete analyzable parts. The name of the database and subsequent data structure descriptions are separated by exclamation marks (!). Data structure name, object type, signature and the description(s) of template argument(s) are parsed by interposing a (;). A template argument description contains the description of one or more classes which are separated by means of a (:). Class descriptions contain attributes sorted out by a (-). Finally, each attribute is represented as a pair of data type and name. The two of them are earmarked by a comma (,).
\par
% and continuing...
Keywords of the language include ds, ds\_pointer, class, class\_pointer, reference and inherits\_from. Keywords are utilized inside attribute representations and specifically as data types to pinpoint particular semantics. If ds is encountered then the current attribute of the class included in a template argument is an embedded data structure while ds\_pointer means that the attribute is a pointer to a data structure. Moreover, its pair will be treated as the name of the data structure and will be used as identification to track its description later on. Similarly, class and class pointer are the first keywords to be met at a class description. Next to the keyword the name of the class is anticipated. When a class contains a reference to another class, the keyword reference is used followed by the name of the latter. Again, the name is utilized to recover the description of the class which is expected to follow inside the same template argument description. Keyword inherits\_from signifies that there is an inheritance relationship. It is expected to be met following the class or class\_pointer keyword. As before, description of the super class is awaited further on in the same template argument description.
\par
% data type checks, all kind of checks
Once the ruby program starts executing it analyzes the user description. If the delimiters and keywords do not fall into place then informative error messages are produced and the program exits. Alternatively, a complex data structure, let us call it Register for clarity, is utilized to keep all that information in a convenient fashion. 
\par
% ruby program description (lower)
Register is an array of complex objects of the Hash class. Each Hash object contains the total information about an STL data structure. The key of the Hash object contains an object of an internally used class and includes attributes name, type, signature, template1\_type and template2\_type of the data structure residing at that record. Template1\_type and template2\_type take values none, primitive, user\_simple and complex. They mean to express the complexity of the class instantiated and are utilized to [separate concerns] achieve the proper transformations and direct the operations respectively when generating code. The second template argument of the Hash object contains yet another internal class. The class contains actually the template description. It includes two attributes of the Hash class each of which keeps a template argument description. Finally, each attribute of the above contain the class definitions, by means of string for the class name and Array of strings for the class attributes.
\par
% the mission of ruby
The program agenda includes preparing the calls to sqlite to create the virtual tables. The calls comprise sql "create table" queries. To this end, create\_vt function is called to create those queries. This function crawls through Register and passes the class description which instantiates a template argument to recursive\_traversal function. Each record in the Register array will fulfill a "create table" query. The concept is to reserve a column for each attribute found at both template arguments descriptions resulting in a flat format. The process is not straightforward. Not all attributes will represent primitive data types. Consequently, this brings us back to the discussion about keywords.
\par
% function mechanics to achieve purpose
Function recursive\_traversal takes as input the total of each class attributes starting from the one found at the signature of the data structure. It loops through its attributes and for each one of them calls function neat\_attributes. The latter processes the data type and if it is of primitive type it returns the attribute as is. If it is a keyword it makes the necessary amendments. Keywords ds and ds\_pointer incur a "references" directive which instructs sqlite to create a foreign key relationship. Since we are talking about an embedded data structure, as afore explained, we need a way to refer to the other data structure from the present one. Each data structure in our model is represented by a virtual table, hence the foreign key relationship is a handy solution. The other keywords concern either an inheritance relationship or a reference to an object of another class. Either way a "jump" is improvised [by means of recursion] to go and perform respective work at the description of the referenced class or superclass. [Once finished, a jump back is carried out]. In the end, all class descriptions found at a template argument description will be handled appropriately. The same procedure is performed in the case of second template argument description.
\par
% summarizing so far - high level
On the road to querying STL data structures of any content as if they were conventional relational tables we have managed to store all the information we need vis-a-vis the data structure(s) at hand and prepare the queries to create their virtual table representation. The latter is achieved by instructing ruby to open a file and write C code. Executing the calls will incur a number of virtual tables at the selected sqlite3 database. To perform operations on those tables we have to teach sqlite3 how to treat them. Fundamental concept of sqlite3's virtual table API is the module struct. For each virtual table implementation a module struct has to be registered with the database engine. It contains callback methods, function pointers which functions implemented by the creator of the virtual table module are assigned to. Specifically, the latter implement operations to be carried out on the virtual table and are anchored to the sqlite engine via the callback methods or hooks. Each of these methods accepts input from the sqlite core and returns output. Necessarily, they behave as a black box. Sqlite does not need to know how the operation is implemented as long as it retrieves the desired output. 
\par
% summarizing - lower
Some of the methods are standard for every virtual table instantiation, or stl data structure instantiation if we look at it at a higher level. Exemplary operations are opening and closing an access point to a virtual table. However, not all operations can be standardized. Searching and retrieving results out of a virtual table masquerading an stl data structure is impossible without knowing its exact content. The description provided by the user fulfills this requirement. Incorporate this knowledge to the respective function implementations is another demanding task.
\par
% where we wanted to get at - automatic code generation
Next job on ruby program's agenda is to open a file and start writing C++ code. In detail, it will automatically generate the non-standard functions, to complement the module functions, implementing search and retrieve operations. To accomplish that, information about the internals of the data structure is needed, information present at Register. 
\par
% why - how automatic code generation - search
When a query towards a virtual table is addressed the sqlite3 core calls the respective callback method, which points to the function implementing the operation. Supplied information includes the cursor pointing at a particular record of the virtual table and the constraint(s) of the query. A way has to be provided to access each virtual table column present in the constraint. Consequently, for each virtual table column, or for each attribute of a class included in the data structure there is an iterator traversing all elements and selecting the eligible ones. Since it is not possible to know in advance name and data type of each column so that it can be traversed, Register is used to print to the C++ file this piece of information.
\par
% why - how automatic code generation - retrieve
After all eligible elements have been identified, it is mandated to recover the virtual table columns selected for display. Since each virtual table column maps to a class attribute, again a way has to be supplied to access each attribute present at the data structure. The task is identical to the above. The mechanics of it include a switch performing case analysis with regards to the column index. For each column index, the name of the get method to fetch the attribute and the data type of the attribute to retrieve it properly are provided by Register and put to the C++ file. Compiling the module functions together with definitions of user supplied classes incurs a working component.
\par
% how it is done in ruby
We have eloquently described how the generated code fulfills its mission to provide data structure specific information in order to be traversed respectively at each case. 
\par
% what happens in the case of more than one data structures
Situation is perplexed if more than one data structures are scheduled for monitoring. Different data structures have the effect that different access methods have to be specified for searching and retrieving results. On this track, we have to instruct the search and retrieve functions to understand which virtual table, or data structure, the query concerns. This is plausible thanks to the first parameter passed, the cursor. The cursor contains a reference to the virtual table instance struct where its name can be retrieved and used to address the correct data structure. Of course, to get the job done, different versions of search and retrieve methods are made available, one for each virtual table implementation. By matching the virtual table name, the correct implementation can be chosen.
\par


\end{document}