<--VIRTUAL TABLE DEFINITION-->

<table_def> ::= 'CREATE VIRTUAL TABLE' <db_name>'.'<virtual_table_name> 
	    	'USING STRUCT VIEW'  <struct_view_name> 
		['WITH REGISTERED C NAME' <base_variable>] 
		'WITH REGISTERED C TYPE' <struct_type>
		['USING LOOP' <loop_variant>]

<db_name> ::= 'identifier'

<virtual_table_name> ::= 'identifier'

<struct_view_name> ::= 'identifier'

<base_variable> ::= 'identifier'

<struct_type> ::= <container> | <object> | <struct>

<loop_variant> ::= 'user-defined-loop-variant'

<container> ::= (<container_class> '<' <type>
<--if associative container-->
	    [',' <type>] '>' ['*']) | <C_container>

<container_class> ::= <stl_class> | <other_container_class>
 
<stl_class> ::= 'list' | 'vector' | 'deque' | 'set' | 
		  'multiset' | 'map' | 'multimap'

<other_container_class> ::= 'SGI_forward_container_concept_compatible'

<type> ::= <struct_type> | <primitive_data_type> ['*']

<C_container> ::= <struct> | <struct>:<struct>
<--For C linked lists and C arrays respectively.
   The loop variants for these containers can be 
   customized by the USING LOOP directive
   which may include macros. The latter can be
   defined at the top of the DSL description.
   See examples/CApp for example use.-->

<object> ::= <class_name> ['*']

<class_name> ::= 'identifier'

<struct> ::= ['struct'] <struct_name> ['*']

<struct_name> ::= 'identifier'

<--STRUCT VIEW DEFINITION-->

<struct_view_def> ::= 'CREATE STRUCT VIEW' <struct_view_name> '(' <column_def> {',' <column_def>} ');'

<struct_view_name> ::= 'identifier'

<column_def> ::=  <primitive_column_def> | 
	     	  <struct_column_def> | 
		  <struct_view_inheritance

<primitive_column_def> ::= <column_name> <primitive_data_type> 'FROM' (<access_statement> | 'self')

<column_name> ::= 'identifier'

<primitive_data_type> ::= 'int' | 'string' | 'double' | 
		      	  'char' | 'float' | 'real' | 
			  'bool' | 'union'

<struct_column_def> ::= 'FOREIGN KEY(<column_name>) FROM' 
		    	(<access_statement> | 'self') 
			[REFERENCES <virtual_table_name>] [POINTER]

<access_statement> ::= 'how_access:eg_function_name()'

<--Instruct the parser to fill a current struct view from one defined
previously by referencing the struct view's name
<struct_view_inheritance> ::= 'INHERITS STRUCT VIEW' <struct_view_name> 
			      ['FROM' <access_statement>]


<--UNION VIEW DEFINITION-->


<union_view_definition> ::= 'CREATE UNION VIEW' <u_name> '('
			    'CASE' <access_stetement>
			    'WHEN' <case> THEN <column_def>
			    {'WHEN' <case> THEN  <column_def>}
			    ');'

<--STANDARD RELATIONAL VIEW DEFINITION-->

<rel_view_def> ::= 'as_per_ansi_92_sql_standard'

<--LOCK DEFINITION-->

<lock_def> ::= 'USE C LOCK' <lock_function> 'UNLOCK'
	       	      	    <unlock_function>';'

<lock_function> ::= 'identifier'

<unlock_function> ::= 'identifier'

