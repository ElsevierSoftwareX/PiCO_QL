== Generative programming ==
To match the template instantiations of user's containers, the library uses a generative approach.
The source code generated makes up the heart of the library's functionality, that is contains the
custom selection and projection functions for the particular template instantiations.
Code generation relies on a user description of those instantiations.

== DSL ==
From this point on, the term structure will appear a lot. This term covers the following:
* object instance
* container instance as per the SGI '''ForwardContainer''' and '''ForwardIterator''' concepts
Additionally, although it should be mentioned separately but for brevity reasons, the term structure also implies pointers to structures.

=== Mapping ===
Prior to describing the building blocks of the DSL, it is important to establish the mapping between the C++ layer and the VT/SQL layer.

Beginning from the latter layer, virtual tables take part in ordinary SQL SELECT computations. Behind the scenes, the SQLite engine calls the implemented interface of a VT, ergo a number of callback methods that define the action at each occasion (open, close, filter, project etc) on a VT. These make the VT querable. As such, the mapping task comes down to representing the valuable information in our structure(s) with SQLite accepted datatypes each occupying a column in the VT.

A roadblock in this process, also evident in the OR impedance mismatch, is the possible depth of OO structures which theoretically may span at infinite levels. The answer to this is decomposition in a familiar style. Specifically, users can rely on two prioritised rules to decompose their C++ structures. If the structure registered with PiCO_QL:
* contains a pointer to a structure, the latter should become a separate VT.
* contains a container instance, the latter should become a separate VT.
The style is familiar because it resembles the normalisation process of relational schema creation.

Those virtual tables whose respective C++ structures do not touch the surface but are met inside other structures have a special column named ''base'' while the VTs of the other, surface, structures devote a column to identify guest structure(s). This is also familiar style and resembles closely relations in the relational algebra. What is more, queries engaging two or more related virtual tables are realised by joins using the implicit notation.

Therefore, joins are commonly established between a VT's reference column to a second and the second's ''base'' column. At this point, a type-handshake of some kind is required because a C++ structure is activated behind the scenes with no type information following it. Type information has been knowingly dismissed in the process to fit in the join mechanism which is basically a give-and-take of address information. To protect users from mistakenly typing a conceptually illegal join, we give them the option to have the ruby parser generate code for type safety.

Conclusively, the set of guidelines to users is:

1. Users should not plan for the special ''base'' column, it is auto-generated.

2. Columns that reference another VT should:

: 1. have INT data type

: 2. include the name and access path to the referenced virtual table as per the available syntaxes

 <nowiki>             FROM TABLE <embedded_VT_name> WITH BASE = <access_path>      # Typesafe syntax

              FROM <access_path>       # No type guarding</nowiki>

: 3. suffix the name of the column with ''_ptr'' if the access path returns a pointer to the referenced structure (require a type handshake).

3. Users can specify queries in ordinary SQL syntax leveraging all SQL facilities that SQLite provides with one restriction. Due to the navigational nature of the underlying (C++) structures, VTs in a query have to be opened, that is ordered in the FROM clause, from the outside, i.e. surface, to the inside, i.e. embedded. Not doing so, will terminate the query with an illegal use error.

=== Datatypes ===
Although PiCO_QL does not use SQLIte3 for storing data, the VT create statements and the data manipulation in the query process has to be done in datatypes that SQLite3 understands.

Generally, SQLite3 uses a dynamic type system. This means that a value type is associated with the value itself. Except for an INTEGER PRIMARY KEY, any other column can be used to store a value of any storage class.

Hence, SQLite3 uses storage classes to categorise types of data and storage classes are slightly more general than datatypes. For instance, the INTEGER storage class includes six different integer datatypes of different lengths. This favors disk efficiency. When the data are brought into memory, they are converted to the most general datatype. Consequently, for the most part the terms _storage class_ and _datatype_ can be used interchangeably.

SQLite3's storage classes include:
* NULL. The value is a NULL value.
* INTEGER. The value is a signed integer, stored in 1, 2, 3, 4, 6, or 8 bytes depending on the magnitude of the value.
* REAL. The value is a floating point value, stored as an 8-byte IEEE floating point number.
* TEXT. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE).
* BLOB. The value is a blob of data, stored exactly as it was input.
The above information is taken from http://sqlite.org/datatype3.html where more information about SQLite3's datatypes can be retrieved.

An advice concerning character arrays is to declare all as TEXT but those that belong to the std::string class. The latter can be defined as STRING.


=== Building blocks ===
The user description, as per the DSL, is a structured plain text description that contains three types of declarations,
* the include header files for application software classes involved and utilised containers,
* element definitions and
* table declarations.

Element definitions resemble class declarations in an even more imperative style. They include the element's name and its attributes, where attribute information includes data type, name and access path. e.g.
 <nowiki>           CREATE ELEMENT TABLE SuperAccount (
            balance DOUBLE FROM get_balance(),
            account_no TEXT FROM get_account_no(),
            rate DOUBLE FROM get_rate(),
            isbn INT FROM get_isbn()
            );</nowiki>

From another perspective, one could observe that element definitions take after relational table definitions.

Table declarations, except for the VT's name, carry information about the underlying nature of the VT, that is the base variable of structure it represents in C++ and its type. Either the type (or template instantiation) or the name of the VT refers to a previously defined element in the description. The rationale is to be able to reuse element definitions in table declarations as well as in other element definitions. e.g.
 <nowiki>           CREATE ELEMENT TABLE Account (
            $SuperAccount,        // Element reuse
            type TEXT FROM type
            );
            CREATE TABLE Bank.Accounts
            WITH BASE=accounts
            AS SELECT * FROM vector<Account>;</nowiki>

The table declaration together with the respective element definition complete a VT definition. Table declarations and element definitions end with a ';' (the primary delimeter) and, as mentioned, element definitions should precede the table declarations that refer to them. Columns in element definitions are separated by ',' (comma).
